function getSheetNameAccordingToMonthAndYear() {
  const date = new Date();
  const name = Utilities.formatDate(date, Session.getScriptTimeZone(), "MMMM-yyyy");

  Logger.log("Current Month: " + name);
  return name;
}


function generateToken(username, password) {
  console.log(Utilities.base64Encode(username + ":" + password))
  return Utilities.base64Encode(username + ":" + password);
}

function generateEncryptedPassword(password) {
  // Generate a SHA-256 hash of the password
  const hashedPassword = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password);

  // Convert the hash bytes to a hex string
  let hexHash = '';
  for (let i = 0; i < hashedPassword.length; i++) {
    const byte = hashedPassword[i];
    hexHash += (byte >>> 4).toString(16);
    hexHash += (byte & 0x0F).toString(16);
  }

  return hexHash;
}

// function test() {
//   var plainPassword = 'myPassword123';
//   var encryptedPassword = generateEncryptedPassword(plainPassword);
//   Logger.log('Encrypted Password: ' + encryptedPassword);
// }

function createSheetAndSelect(sheetName) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();

  // Check if sheet exists
  let sheet = spreadsheet.getSheetByName(sheetName);

  if (!sheet) {
    // Sheet doesn't exist, create it
    sheet = spreadsheet.insertSheet(sheetName);
    // Initialize header row for transaction sheets (not for Category, ShoppingList, Creds, or Trading Log sheets)
    if (sheetName !== 'Category' && 
        sheetName !== 'ShoppingList' && 
        sheetName !== 'Creds' && 
        sheetName !== 'TradingLog' &&
        sheetName !== 'Exchange' &&
        sheetName !== 'AccountOwners' &&
        sheetName !== 'StrategyNames' &&
        !sheetName.includes('Creds')) {
      sheet.appendRow(['ID', 'Amount', 'Category', 'Note', 'Date', 'Payment Method', 'Paid By', 'Type', 'Is Deleted']);
    }
  }

  // Select the sheet
  spreadsheet.setActiveSheet(sheet);
}

function initializeTradingLogSheets() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  
  // Initialize TradingLog sheet
  let tradingLog = spreadsheet.getSheetByName('TradingLog');
  if (!tradingLog) {
    tradingLog = spreadsheet.insertSheet('TradingLog');
    tradingLog.appendRow([
      'ID', 'List', 'Stock', 'Buy Date', 'Buy Price', 'Qty', 'Buy Value', 
      'CMP', 'Current Value', 'Gain Amount', '% Gain', 'Strategy Name', 
      'Target Price', 'Total Potential Gain', 'Remaining Gain', 'Target Value', 
      'Time Frame', 'Account Owner', 'Exchange', 'Status'
    ]);
  }
  
  // Initialize Exchange sheet
  let exchange = spreadsheet.getSheetByName('Exchange');
  if (!exchange) {
    exchange = spreadsheet.insertSheet('Exchange');
    exchange.appendRow(['ID', 'Exchange Name']);
    exchange.appendRow(['=row()', 'India']);
    exchange.appendRow(['=row()', 'Germany']);
    exchange.appendRow(['=row()', 'US']);
  }
  
  // Initialize AccountOwners sheet
  let accountOwners = spreadsheet.getSheetByName('AccountOwners');
  if (!accountOwners) {
    accountOwners = spreadsheet.insertSheet('AccountOwners');
    accountOwners.appendRow(['ID', 'Account Owner']);
    accountOwners.appendRow(['=row()', 'Own']);
    accountOwners.appendRow(['=row()', 'Ai']);
    accountOwners.appendRow(['=row()', 'Aj']);
  }
  
  // Initialize StrategyNames sheet
  let strategyNames = spreadsheet.getSheetByName('StrategyNames');
  if (!strategyNames) {
    strategyNames = spreadsheet.insertSheet('StrategyNames');
    strategyNames.appendRow(['ID', 'Strategy Name']);
    strategyNames.appendRow(['=row()', 'Super Strategy']);
    strategyNames.appendRow(['=row()', 'SMA +BDC']);
    strategyNames.appendRow(['=row()', 'Support Resistance']);
    strategyNames.appendRow(['=row()', 'Envelop']);
    strategyNames.appendRow(['=row()', 'Knox']);
    strategyNames.appendRow(['=row()', '52 weeks High Low']);
    strategyNames.appendRow(['=row()', '67 ka Funda']);
    strategyNames.appendRow(['=row()', 'ABCD']);
  }
}

const name = getSheetNameAccordingToMonthAndYear();
createSheetAndSelect(name);
// const app = SpreadsheetApp.openByUrl('https://docs.google.com/spreadsheets/d/14dbD61rTWw4EnXopoAAbP8kCQqFnI7Z7thJ3i7FUoPU/edit#gid=0');
const spreadsheet = SpreadsheetApp.getActiveSpreadsheet()
const transactionsSheet = spreadsheet.getSheetByName(name);

// Logger.log(transactionsSheet.getDataRange().getValues());


const categoriesSheet = spreadsheet.getSheetByName('Category');
const shoppingListSheet = spreadsheet.getSheetByName('ShoppingList');
const credsSheet = spreadsheet.getSheetByName('Creds');

// Initialize Trading Log master data sheets if they don't exist (called after spreadsheet is defined)
initializeTradingLogSheets();


function doGet(e) {
  const action = e.parameter.action;
  const sheet = e.parameter.sheet;

  let data;

  switch (action) {
    case 'readTransactions':
      data = readTransactions();
      break;
    case 'readSingleTransaction':
      const id = e.parameter.id;
      data = readSingleTransaction(sheet, id);
      break;
    case 'readShoppingList':
      data = readShoppingList();
      break;
    case 'readCategories':
      data = readCategories();
      break;
    case 'readTradingLogs':
      data = readTradingLogs();
      break;
    case 'readSingleTradingLog':
      const tradeId = e.parameter.id;
      data = readSingleTradingLog(tradeId);
      break;
    case 'readExchanges':
      data = readExchanges();
      break;
    case 'readAccountOwners':
      data = readAccountOwners();
      break;
    case 'readStrategyNames':
      data = readStrategyNames();
      break;
    default:
      data = { error: 'Invalid action' };
  }

  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  const data = JSON.parse(e.postData.contents);
  const action = e.parameter.action;
  let result; // Declare result variable
  
  switch (action) {
    case 'create':
      createData(data, data.sheetName);
      const msg = getResponseText(data.sheetName);
      result = { message: msg };
      break;
    case 'login':
      result = processLogin(data);
      break;
    case 'update':
      const updatedData = updateData(data.values, data.rowIndex, data.sheetName);
      // const updatedData = arr.map(
      //   ([
      //     id,
      //     amount,
      //     category,
      //     note,
      //     date,
      //     paymentMethod,
      //     paidBy,
      //     type,
      //     isDeleted,
      //   ]) => ({
      //     id,
      //     amount,
      //     category,
      //     note,
      //     date: new Date(date),
      //     paymentMethod,
      //     paidBy,
      //     type,
      //     isDeleted,
      //   }))[0];
      result = { message: 'Transaction updated successfully', data: updatedData };
      break;
    case 'delete':
      const rowIndex = e.parameter.rowIndex;
      deleteData(data.rowIndex, data.sheetName);
      result = { message: 'Transaction deleted successfully' };
      break;
    case 'createTradingLog':
      result = createTradingLog(data);
      break;
    case 'updateTradingLog':
      result = updateTradingLog(data);
      break;
    case 'deleteTradingLog':
      result = deleteTradingLog(data.rowIndex);
      break;
    default:
      result = { error: 'Invalid action' };
  }
  return ContentService.createTextOutput(JSON.stringify(result))
    .setMimeType(ContentService.MimeType.JSON)


}
getSheets = () => {
  const currentDate = new Date();
  Logger.log(`Executing method:testMethod`);
  const currentYear = currentDate.getFullYear().toString();
  const currentMonth = currentDate.getMonth();
  const sheets = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(monthName => `${monthName}-${currentYear}`);
  return { sheets, currentMonth };
}

function parseDateFromSheet(dateValue) {
  // Handle null/undefined/empty values
  if (!dateValue) {
    Logger.log('Warning: Empty date value encountered');
    return new Date();
  }

  // Handle Date objects from Google Sheets (when stored as Date type)
  if (dateValue instanceof Date) {
    // Check if it's a valid date
    if (!isNaN(dateValue.getTime())) {
      return dateValue;
    }
    Logger.log('Warning: Invalid Date object encountered');
    return new Date();
  }

  // Handle string dates in DD-MM-YYYY format (when stored as text)
  if (typeof dateValue === 'string') {
    // Try DD-MM-YYYY format first (e.g., "15-1-2026" or "15-01-2026")
    if (dateValue.includes('-')) {
      const parts = dateValue.split('-');
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed in JavaScript
        const year = parseInt(parts[2], 10);

        // Validate parsed values
        if (!isNaN(day) && !isNaN(month) && !isNaN(year) &&
            day >= 1 && day <= 31 && month >= 0 && month <= 11 && year > 1900) {
          const parsedDate = new Date(year, month, day);
          Logger.log('Parsed date from DD-MM-YYYY format:', dateValue, '->', parsedDate);
          return parsedDate;
        }
      }
    }

    // Try ISO format or other standard formats
    const parsedDate = new Date(dateValue);
    if (!isNaN(parsedDate.getTime())) {
      Logger.log('Parsed date from string:', dateValue, '->', parsedDate);
      return parsedDate;
    }
  }

  // If all parsing attempts fail, log warning and return current date
  Logger.log('Warning: Could not parse date value:', dateValue, 'Type:', typeof dateValue);
  return new Date();
}

function readTransactions() {
  // Add the sheet names here
  const { sheets, currentMonth } = getSheets();
  Logger.log('Reading transactions - Current month index:', currentMonth);
  Logger.log('Sheets to read:', sheets.slice(0, currentMonth + 1));

  let allTransactions = [];
  for (let i = 0; i < currentMonth + 1; i++) {
    let str = sheets[i];
    Logger.log('Processing sheet:', str);
    createSheetAndSelect(str);
    const sheet = spreadsheet.getSheetByName(str);
    if (sheet) {
      const values = sheet.getDataRange().getValues();
      Logger.log('Sheet ' + str + ' has ' + values.length + ' rows');
      // Check if sheet has data beyond header row
      if (values.length > 1) {
        values.shift(); // Remove header row
        Logger.log('Adding ' + values.length + ' transactions from ' + str);
        allTransactions.push(...values);
      } else {
        Logger.log('Sheet ' + str + ' has no data rows (only header or empty)');
      }
    } else {
      Logger.log('Sheet ' + str + ' not found');
    }
  }
  const filteredTransactions = allTransactions.filter(row => row && row.length > 0); // Filter out empty or invalid rows

  const payload = {
    data: filteredTransactions.map(
      ([
        id,
        amount,
        category,
        note,
        date,
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      ]) => ({
        id,
        amount,
        category,
        note,
        date: parseDateFromSheet(date),
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      })
    ),
    length: filteredTransactions.length
  }

  Logger.log('Read transactions payload:', payload)
  Logger.log('Number of transactions:', payload.length)
  return payload;
}

function readSingleTransaction(sheetName, rowIndex) {
  const sheet = spreadsheet.getSheetByName(sheetName);
  
  // Check if sheet exists
  if (!sheet) {
    Logger.log("Sheet not found: " + sheetName);
    return { error: 'Sheet not found', data: null };
  }
  
  // Validate rowIndex
  if (!rowIndex || rowIndex < 1) {
    Logger.log("Invalid row index: " + rowIndex);
    return { error: 'Invalid row index', data: null };
  }
  
  // Check if row exists
  const lastRow = sheet.getLastRow();
  if (rowIndex > lastRow) {
    Logger.log("Row index " + rowIndex + " exceeds last row " + lastRow);
    return { error: 'Row not found', data: null };
  }
  
  // Get the row data
  const lastColumn = sheet.getLastColumn();
  const dataRange = sheet.getRange(rowIndex, 1, 1, lastColumn);
  const values = dataRange.getValues();
  
  Logger.log("Read transaction from sheet: " + sheetName + ", row: " + rowIndex);
  return { data: values };
}

///////////////////////////
function readData(sheetName) {
  const res = sheetName.getDataRange().getValues();
  return res;
}

function readShoppingList() {
  const res = shoppingListSheet.getDataRange().getValues();
  return res.map(([id, name, quantity, isAdded, isDeleted]) => ({
    id,
    name,
    quantity,
    isAdded,
    isDeleted,
  }));
}

function readCategories() {
  const res = categoriesSheet.getDataRange().getValues();
  // Skip header row and map to objects
  return res.slice(1).map(([id, name, subType, type, icon, isDeleted]) => ({
    id,
    name,
    subType,
    type,
    icon: icon || 'category',
    isDeleted: isDeleted === true || isDeleted === 'true'
  }));
}


function createData(data, sheetName) {
  createSheetAndSelect(sheetName);
  const selectedSheet = spreadsheet.getSheetByName(sheetName);
  switch (sheetName) {
    case 'transaction':
      selectedSheet.appendRow(["=row()", data.amount, data.category, data.note, data.date, data.paymentMethod, data.paidBy, data.type, false]);
      break;
    case 'shoppingList':
      shoppingListSheet.appendRow(["=row()", data.name, data.quantity, data.isAdded, data.isDeleted]);
      break;
    default:
      selectedSheet.appendRow(["=row()", data.amount, data.category, data.note, data.date, data.paymentMethod, data.paidBy, data.type, false]);

  }
}


function updateData(data, rowIndex, sheetName) {
  if (sheetName == 'shoppingList') {
    return clearAndInsertData(data);
  } else {
    createSheetAndSelect(sheetName);
    const selectedSheet = spreadsheet.getSheetByName(sheetName);
    const range = selectedSheet.getRange(rowIndex, 1, 1, selectedSheet.getLastColumn());
    range.setValues([["=row()", data.amount, data.category, data.note, data.date, data.paymentMethod, data.paidBy, data.type, 'false']])
    return range.getValues().map(
      ([
        id,
        amount,
        category,
        note,
        date,
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      ]) => ({
        id,
        amount,
        category,
        note,
        date: parseDateFromSheet(date),
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      }))[0]
  }
}

function deleteData(rowIndex, sheetName) {
  createSheetAndSelect(sheetName);
  const selectedSheet = spreadsheet.getSheetByName(sheetName);
  selectedSheet.deleteRow(rowIndex);
}

function getResponseText(sheetName) {
  switch (sheetName) {
    case 'transaction':
      return 'Transaction updated successfully';
      break;
    case 'shoppingList':
      return 'New item added successfully';
      break;
    default:
      return 'Transaction updated successfully';

  }

}

function processLogin(data) {
  const { username, password } = { ...data };
  Logger.log(generateEncryptedPassword(password));
  const users = credsSheet.getDataRange().getValues();
  const foundUser = users.find(user => user[0] === username);
  if (foundUser) {
    const [fetchedUser, fetchedPass] = foundUser;
    if (fetchedUser === username && fetchedPass === generateEncryptedPassword(password)) {
      const token = generateToken(username, new Date())
      return { token, message: 'Login successful!' };
    } else {
      return { token: '', message: 'Username or password is incorrect, Try again!' };
    }
  } else {
    return { token: '', message: 'User not found,Please sign up!' };
  }

}

function handleUnauthorized(msg) {
  const response = ContentService.createTextOutput(msg);
  response.setStatusCode(401);
  return response;
}

function clearAndInsertData(payload) {

  Logger.log('executing clear and insert')
  const lastRow = shoppingListSheet.getLastRow();


  if (lastRow > 1) {
    shoppingListSheet.getRange(2, 1, lastRow - 1, shoppingListSheet.getLastColumn()).clearContent();
  }

  const newData = payload.map(obj => ["=row()", obj.name, obj.quantity, obj.isAdded, 'false'])
  Logger.log(newData);

  // shoppingListSheet.getRange(2, 1, newData.length, newData[0].length).setValues(newData);

  const range = shoppingListSheet.getRange(2, 1, newData.length, newData[0].length);
  range.setValues(newData);
  return range.getValues().map(
    ([
      id,
      name,
      quantity,
      isAdded,
      isDeleted,
    ]) => ({
      id,
      name,
      quantity,
      isAdded,
      isDeleted,
    }));
}

// ==================== Trading Log Functions ====================

function calculateTradingLogFields(trade) {
  const buyPrice = parseFloat(trade['Buy Price']) || 0;
  const qty = parseInt(trade.Qty) || 0;
  const cmp = parseFloat(trade.CMP) || buyPrice; // Default to Buy Price if CMP not provided
  const targetPrice = parseFloat(trade['Target Price']) || 0;
  const buyDate = new Date(trade['Buy Date']);
  const today = new Date();
  
  // Calculate fields
  const buyValue = buyPrice * qty;
  const currentValue = cmp * qty;
  const gainAmount = currentValue - buyValue;
  const percentGain = buyValue !== 0 ? (gainAmount / buyValue) * 100 : 0;
  const targetValue = targetPrice * qty;
  const totalPotentialGain = buyPrice !== 0 ? ((targetPrice - buyPrice) / buyPrice) * 100 : 0;
  const remainingGain = buyPrice !== 0 ? ((targetPrice - cmp) / buyPrice) * 100 : 0;
  const timeFrame = Math.floor((today - buyDate) / (1000 * 60 * 60 * 24)); // Days
  
  return {
    'Buy Value': buyValue.toFixed(2),
    'Current Value': currentValue.toFixed(2),
    'Gain Amount': gainAmount.toFixed(2),
    '% Gain': percentGain.toFixed(2) + '%',
    'Target Value': targetValue.toFixed(2),
    'Total Potential Gain': totalPotentialGain.toFixed(2) + '%',
    'Remaining Gain': remainingGain.toFixed(2) + '%',
    'Time Frame': timeFrame
  };
}

function readTradingLogs() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName('TradingLog');
  
  if (!sheet) {
    Logger.log('TradingLog sheet not found');
    return { data: [], length: 0 };
  }
  
  const values = sheet.getDataRange().getValues();
  if (values.length <= 1) {
    return { data: [], length: 0 };
  }
  
  // Skip header row
  const dataRows = values.slice(1);
  const filteredRows = dataRows.filter(row => row && row.length > 0);
  
  const tradingLogs = filteredRows.map(([
    id,
    list,
    stock,
    buyDate,
    buyPrice,
    qty,
    buyValue,
    cmp,
    currentValue,
    gainAmount,
    percentGain,
    strategyName,
    targetPrice,
    totalPotentialGain,
    remainingGain,
    targetValue,
    timeFrame,
    accountOwner,
    exchange,
    status
  ]) => ({
    id,
    List: list || '',
    Stock: stock || '',
    'Buy Date': buyDate ? parseDateFromSheet(buyDate) : new Date(),
    'Buy Price': parseFloat(buyPrice) || 0,
    Qty: parseInt(qty) || 0,
    'Buy Value': buyValue || '',
    CMP: parseFloat(cmp) || 0,
    'Current Value': currentValue || '',
    'Gain Amount': gainAmount || '',
    '% Gain': percentGain || '',
    'Strategy Name': strategyName || '',
    'Target Price': targetPrice || '',
    'Total Potential Gain': totalPotentialGain || '',
    'Remaining Gain': remainingGain || '',
    'Target Value': targetValue || '',
    'Time Frame': parseInt(timeFrame) || 0,
    'Account Owner': accountOwner || '',
    Exchange: exchange || '',
    Status: status || 'Active'
  }));
  
  Logger.log('Read trading logs:', tradingLogs.length);
  return { data: tradingLogs, length: tradingLogs.length };
}

function readSingleTradingLog(rowIndex) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName('TradingLog');
  
  if (!sheet) {
    return { error: 'TradingLog sheet not found', data: null };
  }
  
  if (!rowIndex || rowIndex < 2) {
    return { error: 'Invalid row index', data: null };
  }
  
  const lastRow = sheet.getLastRow();
  if (rowIndex > lastRow) {
    return { error: 'Row not found', data: null };
  }
  
  const values = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  return {
    data: {
      id: values[0],
      List: values[1] || '',
      Stock: values[2] || '',
      'Buy Date': parseDateFromSheet(values[3]),
      'Buy Price': parseFloat(values[4]) || 0,
      Qty: parseInt(values[5]) || 0,
      'Buy Value': values[6] || '',
      CMP: parseFloat(values[7]) || 0,
      'Current Value': values[8] || '',
      'Gain Amount': values[9] || '',
      '% Gain': values[10] || '',
      'Strategy Name': values[11] || '',
      'Target Price': values[12] || '',
      'Total Potential Gain': values[13] || '',
      'Remaining Gain': values[14] || '',
      'Target Value': values[15] || '',
      'Time Frame': parseInt(values[16]) || 0,
      'Account Owner': values[17] || '',
      Exchange: values[18] || '',
      Status: values[19] || 'Active'
    }
  };
}

function createTradingLog(data) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = spreadsheet.getSheetByName('TradingLog');
  
  if (!sheet) {
    initializeTradingLogSheets();
    sheet = spreadsheet.getSheetByName('TradingLog');
  }
  
  // Calculate all fields
  const calculated = calculateTradingLogFields(data);
  
  // Format buy date
  const buyDate = data['Buy Date'] instanceof Date 
    ? data['Buy Date'] 
    : parseDateFromSheet(data['Buy Date']);
  
  // Insert row
  sheet.appendRow([
    "=row()", // ID
    data.List || '',
    data.Stock || '',
    buyDate,
    parseFloat(data['Buy Price']) || 0,
    parseInt(data.Qty) || 0,
    calculated['Buy Value'],
    parseFloat(data.CMP) || parseFloat(data['Buy Price']) || 0,
    calculated['Current Value'],
    calculated['Gain Amount'],
    calculated['% Gain'],
    data['Strategy Name'] || '',
    parseFloat(data['Target Price']) || 0,
    calculated['Total Potential Gain'],
    calculated['Remaining Gain'],
    calculated['Target Value'],
    calculated['Time Frame'],
    data['Account Owner'] || '',
    data.Exchange || '',
    data.Status || 'Active'
  ]);
  
  return { message: 'Trading log created successfully' };
}

function updateTradingLog(data) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName('TradingLog');
  
  if (!sheet) {
    return { error: 'TradingLog sheet not found' };
  }
  
  const rowIndex = data.rowIndex;
  if (!rowIndex || rowIndex < 2) {
    return { error: 'Invalid row index' };
  }
  
  // Calculate all fields
  const calculated = calculateTradingLogFields(data);
  
  // Format buy date
  const buyDate = data['Buy Date'] instanceof Date 
    ? data['Buy Date'] 
    : parseDateFromSheet(data['Buy Date']);
  
  // Update row
  const range = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn());
  range.setValues([[
    "=row()", // ID
    data.List || '',
    data.Stock || '',
    buyDate,
    parseFloat(data['Buy Price']) || 0,
    parseInt(data.Qty) || 0,
    calculated['Buy Value'],
    parseFloat(data.CMP) || parseFloat(data['Buy Price']) || 0,
    calculated['Current Value'],
    calculated['Gain Amount'],
    calculated['% Gain'],
    data['Strategy Name'] || '',
    parseFloat(data['Target Price']) || 0,
    calculated['Total Potential Gain'],
    calculated['Remaining Gain'],
    calculated['Target Value'],
    calculated['Time Frame'],
    data['Account Owner'] || '',
    data.Exchange || '',
    data.Status || 'Active'
  ]]);
  
  return { message: 'Trading log updated successfully' };
}

function deleteTradingLog(rowIndex) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName('TradingLog');
  
  if (!sheet) {
    return { error: 'TradingLog sheet not found' };
  }
  
  if (!rowIndex || rowIndex < 2) {
    return { error: 'Invalid row index' };
  }
  
  sheet.deleteRow(rowIndex);
  return { message: 'Trading log deleted successfully' };
}

function readExchanges() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName('Exchange');
  
  if (!sheet) {
    return [];
  }
  
  const values = sheet.getDataRange().getValues();
  // Skip header row
  return values.slice(1).map(([id, name]) => ({
    id,
    name: name || ''
  })).filter(item => item.name);
}

function readAccountOwners() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName('AccountOwners');
  
  if (!sheet) {
    return [];
  }
  
  const values = sheet.getDataRange().getValues();
  // Skip header row
  return values.slice(1).map(([id, name]) => ({
    id,
    name: name || ''
  })).filter(item => item.name);
}

function readStrategyNames() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName('StrategyNames');
  
  if (!sheet) {
    return [];
  }
  
  const values = sheet.getDataRange().getValues();
  // Skip header row
  return values.slice(1).map(([id, name]) => ({
    id,
    name: name || ''
  })).filter(item => item.name);
}


