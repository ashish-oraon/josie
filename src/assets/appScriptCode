function getSheetNameAccordingToMonthAndYear() {
  const date = new Date();
  const name = Utilities.formatDate(date, Session.getScriptTimeZone(), "MMMM-yyyy");

  Logger.log("Current Month: " + name);
  return name;
}


function generateToken(username, password) {
  console.log(Utilities.base64Encode(username + ":" + password))
  return Utilities.base64Encode(username + ":" + password);
}

function generateEncryptedPassword(password) {
  // Generate a SHA-256 hash of the password
  const hashedPassword = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password);

  // Convert the hash bytes to a hex string
  let hexHash = '';
  for (let i = 0; i < hashedPassword.length; i++) {
    const byte = hashedPassword[i];
    hexHash += (byte >>> 4).toString(16);
    hexHash += (byte & 0x0F).toString(16);
  }

  return hexHash;
}

// function test() {
//   var plainPassword = 'myPassword123';
//   var encryptedPassword = generateEncryptedPassword(plainPassword);
//   Logger.log('Encrypted Password: ' + encryptedPassword);
// }

function createSheetAndSelect(sheetName) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();

  // Check if sheet exists
  let sheet = spreadsheet.getSheetByName(sheetName);

  if (!sheet) {
    // Sheet doesn't exist, create it
    sheet = spreadsheet.insertSheet(sheetName);
    // Initialize header row for transaction sheets (not for Category, ShoppingList, or Creds)
    if (sheetName !== 'Category' && sheetName !== 'ShoppingList' && sheetName !== 'Creds' && !sheetName.includes('Creds')) {
      sheet.appendRow(['ID', 'Amount', 'Category', 'Note', 'Date', 'Payment Method', 'Paid By', 'Type', 'Is Deleted']);
    }
  }

  // Select the sheet
  spreadsheet.setActiveSheet(sheet);
}

const name = getSheetNameAccordingToMonthAndYear();
createSheetAndSelect(name);
// const app = SpreadsheetApp.openByUrl('https://docs.google.com/spreadsheets/d/14dbD61rTWw4EnXopoAAbP8kCQqFnI7Z7thJ3i7FUoPU/edit#gid=0');
const spreadsheet = SpreadsheetApp.getActiveSpreadsheet()
const transactionsSheet = spreadsheet.getSheetByName(name);

// Logger.log(transactionsSheet.getDataRange().getValues());


const categoriesSheet = spreadsheet.getSheetByName('Category');
const shoppingListSheet = spreadsheet.getSheetByName('ShoppingList');
const credsSheet = spreadsheet.getSheetByName('Creds');


function doGet(e) {
  const action = e.parameter.action;
  const sheet = e.parameter.sheet;

  let data;

  switch (action) {
    case 'readTransactions':
      data = readTransactions();
      break;
    case 'readSingleTransaction':
      const id = e.parameter.id;
      data = readSingleTransaction(sheet, id);
      break;
    case 'readShoppingList':
      data = readShoppingList();
      break;
    case 'readCategories':
      data = readCategories();
      break;
    default:
      data = { error: 'Invalid action' };
  }

  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  const data = JSON.parse(e.postData.contents);
  const action = e.parameter.action;
  let result; // Declare result variable
  
  switch (action) {
    case 'create':
      createData(data, data.sheetName);
      const msg = getResponseText(data.sheetName);
      result = { message: msg };
      break;
    case 'login':
      result = processLogin(data);
      break;
    case 'update':
      const updatedData = updateData(data.values, data.rowIndex, data.sheetName);
      // const updatedData = arr.map(
      //   ([
      //     id,
      //     amount,
      //     category,
      //     note,
      //     date,
      //     paymentMethod,
      //     paidBy,
      //     type,
      //     isDeleted,
      //   ]) => ({
      //     id,
      //     amount,
      //     category,
      //     note,
      //     date: new Date(date),
      //     paymentMethod,
      //     paidBy,
      //     type,
      //     isDeleted,
      //   }))[0];
      result = { message: 'Transaction updated successfully', data: updatedData };
      break;
    case 'delete':
      const rowIndex = e.parameter.rowIndex;
      deleteData(data.rowIndex, data.sheetName);
      result = { message: 'Transaction deleted successfully' };
      break;
    default:
      result = { error: 'Invalid action' };
  }
  return ContentService.createTextOutput(JSON.stringify(result))
    .setMimeType(ContentService.MimeType.JSON)


}
getSheets = () => {
  const currentDate = new Date();
  Logger.log(`Executing method:testMethod`);
  const currentYear = currentDate.getFullYear().toString();
  const currentMonth = currentDate.getMonth();
  const sheets = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(monthName => `${monthName}-${currentYear}`);
  return { sheets, currentMonth };
}

function parseDateFromSheet(dateValue) {
  // Handle null/undefined/empty values
  if (!dateValue) {
    Logger.log('Warning: Empty date value encountered');
    return new Date();
  }

  // Handle Date objects from Google Sheets (when stored as Date type)
  if (dateValue instanceof Date) {
    // Check if it's a valid date
    if (!isNaN(dateValue.getTime())) {
      return dateValue;
    }
    Logger.log('Warning: Invalid Date object encountered');
    return new Date();
  }

  // Handle string dates in DD-MM-YYYY format (when stored as text)
  if (typeof dateValue === 'string') {
    // Try DD-MM-YYYY format first (e.g., "15-1-2026" or "15-01-2026")
    if (dateValue.includes('-')) {
      const parts = dateValue.split('-');
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed in JavaScript
        const year = parseInt(parts[2], 10);

        // Validate parsed values
        if (!isNaN(day) && !isNaN(month) && !isNaN(year) &&
            day >= 1 && day <= 31 && month >= 0 && month <= 11 && year > 1900) {
          const parsedDate = new Date(year, month, day);
          Logger.log('Parsed date from DD-MM-YYYY format:', dateValue, '->', parsedDate);
          return parsedDate;
        }
      }
    }

    // Try ISO format or other standard formats
    const parsedDate = new Date(dateValue);
    if (!isNaN(parsedDate.getTime())) {
      Logger.log('Parsed date from string:', dateValue, '->', parsedDate);
      return parsedDate;
    }
  }

  // If all parsing attempts fail, log warning and return current date
  Logger.log('Warning: Could not parse date value:', dateValue, 'Type:', typeof dateValue);
  return new Date();
}

function readTransactions() {
  // Add the sheet names here
  const { sheets, currentMonth } = getSheets();
  Logger.log('Reading transactions - Current month index:', currentMonth);
  Logger.log('Sheets to read:', sheets.slice(0, currentMonth + 1));

  let allTransactions = [];
  for (let i = 0; i < currentMonth + 1; i++) {
    let str = sheets[i];
    Logger.log('Processing sheet:', str);
    createSheetAndSelect(str);
    const sheet = spreadsheet.getSheetByName(str);
    if (sheet) {
      const values = sheet.getDataRange().getValues();
      Logger.log('Sheet ' + str + ' has ' + values.length + ' rows');
      // Check if sheet has data beyond header row
      if (values.length > 1) {
        values.shift(); // Remove header row
        Logger.log('Adding ' + values.length + ' transactions from ' + str);
        allTransactions.push(...values);
      } else {
        Logger.log('Sheet ' + str + ' has no data rows (only header or empty)');
      }
    } else {
      Logger.log('Sheet ' + str + ' not found');
    }
  }
  const filteredTransactions = allTransactions.filter(row => row && row.length > 0); // Filter out empty or invalid rows

  const payload = {
    data: filteredTransactions.map(
      ([
        id,
        amount,
        category,
        note,
        date,
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      ]) => ({
        id,
        amount,
        category,
        note,
        date: parseDateFromSheet(date),
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      })
    ),
    length: filteredTransactions.length
  }

  Logger.log('Read transactions payload:', payload)
  Logger.log('Number of transactions:', payload.length)
  return payload;
}

function readSingleTransaction(sheetName, rowIndex) {
  const sheet = spreadsheet.getSheetByName(sheetName);
  
  // Check if sheet exists
  if (!sheet) {
    Logger.log("Sheet not found: " + sheetName);
    return { error: 'Sheet not found', data: null };
  }
  
  // Validate rowIndex
  if (!rowIndex || rowIndex < 1) {
    Logger.log("Invalid row index: " + rowIndex);
    return { error: 'Invalid row index', data: null };
  }
  
  // Check if row exists
  const lastRow = sheet.getLastRow();
  if (rowIndex > lastRow) {
    Logger.log("Row index " + rowIndex + " exceeds last row " + lastRow);
    return { error: 'Row not found', data: null };
  }
  
  // Get the row data
  const lastColumn = sheet.getLastColumn();
  const dataRange = sheet.getRange(rowIndex, 1, 1, lastColumn);
  const values = dataRange.getValues();
  
  Logger.log("Read transaction from sheet: " + sheetName + ", row: " + rowIndex);
  return { data: values };
}

///////////////////////////
function readData(sheetName) {
  const res = sheetName.getDataRange().getValues();
  return res;
}

function readShoppingList() {
  const res = shoppingListSheet.getDataRange().getValues();
  return res.map(([id, name, quantity, isAdded, isDeleted]) => ({
    id,
    name,
    quantity,
    isAdded,
    isDeleted,
  }));
}

function readCategories() {
  const res = categoriesSheet.getDataRange().getValues();
  // Skip header row and map to objects
  return res.slice(1).map(([id, name, subType, type, icon, isDeleted]) => ({
    id,
    name,
    subType,
    type,
    icon: icon || 'category',
    isDeleted: isDeleted === true || isDeleted === 'true'
  }));
}


function createData(data, sheetName) {
  createSheetAndSelect(sheetName);
  const selectedSheet = spreadsheet.getSheetByName(sheetName);
  switch (sheetName) {
    case 'transaction':
      selectedSheet.appendRow(["=row()", data.amount, data.category, data.note, data.date, data.paymentMethod, data.paidBy, data.type, false]);
      break;
    case 'shoppingList':
      shoppingListSheet.appendRow(["=row()", data.name, data.quantity, data.isAdded, data.isDeleted]);
      break;
    default:
      selectedSheet.appendRow(["=row()", data.amount, data.category, data.note, data.date, data.paymentMethod, data.paidBy, data.type, false]);

  }
}


function updateData(data, rowIndex, sheetName) {
  if (sheetName == 'shoppingList') {
    return clearAndInsertData(data);
  } else {
    createSheetAndSelect(sheetName);
    const selectedSheet = spreadsheet.getSheetByName(sheetName);
    const range = selectedSheet.getRange(rowIndex, 1, 1, selectedSheet.getLastColumn());
    range.setValues([["=row()", data.amount, data.category, data.note, data.date, data.paymentMethod, data.paidBy, data.type, 'false']])
    return range.getValues().map(
      ([
        id,
        amount,
        category,
        note,
        date,
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      ]) => ({
        id,
        amount,
        category,
        note,
        date: parseDateFromSheet(date),
        paymentMethod,
        paidBy,
        type,
        isDeleted,
      }))[0]
  }
}

function deleteData(rowIndex, sheetName) {
  createSheetAndSelect(sheetName);
  const selectedSheet = spreadsheet.getSheetByName(sheetName);
  selectedSheet.deleteRow(rowIndex);
}

function getResponseText(sheetName) {
  switch (sheetName) {
    case 'transaction':
      return 'Transaction updated successfully';
      break;
    case 'shoppingList':
      return 'New item added successfully';
      break;
    default:
      return 'Transaction updated successfully';

  }

}

function processLogin(data) {
  const { username, password } = { ...data };
  Logger.log(generateEncryptedPassword(password));
  const users = credsSheet.getDataRange().getValues();
  const foundUser = users.find(user => user[0] === username);
  if (foundUser) {
    const [fetchedUser, fetchedPass] = foundUser;
    if (fetchedUser === username && fetchedPass === generateEncryptedPassword(password)) {
      const token = generateToken(username, new Date())
      return { token, message: 'Login successful!' };
    } else {
      return { token: '', message: 'Username or password is incorrect, Try again!' };
    }
  } else {
    return { token: '', message: 'User not found,Please sign up!' };
  }

}

function handleUnauthorized(msg) {
  const response = ContentService.createTextOutput(msg);
  response.setStatusCode(401);
  return response;
}

function clearAndInsertData(payload) {

  Logger.log('executing clear and insert')
  const lastRow = shoppingListSheet.getLastRow();


  if (lastRow > 1) {
    shoppingListSheet.getRange(2, 1, lastRow - 1, shoppingListSheet.getLastColumn()).clearContent();
  }

  const newData = payload.map(obj => ["=row()", obj.name, obj.quantity, obj.isAdded, 'false'])
  Logger.log(newData);

  // shoppingListSheet.getRange(2, 1, newData.length, newData[0].length).setValues(newData);

  const range = shoppingListSheet.getRange(2, 1, newData.length, newData[0].length);
  range.setValues(newData);
  return range.getValues().map(
    ([
      id,
      name,
      quantity,
      isAdded,
      isDeleted,
    ]) => ({
      id,
      name,
      quantity,
      isAdded,
      isDeleted,
    }));
}


